A->B,B->C(A-->C) : translate pipe
B->C : language stack (can recognize A and B)  A->B || B->C || A->B,B->C
C : interpret C instructions


1. control logic

	s1: A->B
	s2: B->C
	s3: C

	for item in Si:
		if left->right match left
		then do the action (translate or interpret)
			if the action is translate
				the right is the output
				if right === left 
					output the right
				else
					iterator the right, put the output as input
		else output the unmatched input


2. define units and compose them together.
	units:
		u1: A->B
		u2: B->C
		u3: C

	compose:
		A->B,B->C as A-->C like pipe
		A-->C || B-->C like Union operator


3. 嵌入lisp子解释函数支持
语法:
	(LOAD_TRANSLATIONS <语法表达式>)
	(ADD_TRANSLATIONS <语法表达式>)

支持:
	1. 独立LoadWll0相关函数[done]
	2. 子解释添加LOAD_TRANSLATIONS标记的解释[done]
	3. 注意输入状态[done]

SelfExplain自解释和Translate翻译函数的功能分布改造
	改造思路: 
		1. Translate函数继续保持文法结构翻译的简洁性,但是需要考虑对直接引用源语言变量值的支持.[done]
		2. SelfExplain简化对自解释/文法输出的分支判断(之前是通过识别$WLL0来实现的),把他们统一视为对文法中特殊REMARK的处理.[done]

问题一:	是否需要保留原有的自解释语法标记?
	解决方案: 可以保留原有的自解释语法标记,以便直接兼容原有文法. 括号标记文法是可以和原有自解释语法标记兼容的.

问题二: 考虑在对自解释输出代码进行求值的时候,怎样弥合Symbols和abc类中定义的ValueType类型的差异?
是通过扩展Symbols的类型来解决问题,还是通过单独的数据栈来解决问题?
同时需要考虑对变量赋值和引用的处理方法?

问题三: 是时候考虑对 直接引用源语言中文法变量值 的支持了.
	解决方案: 修改Translate算法

其他优化点:
1. 优化代码结构: 语法分析器分离,语法转换器分离,语法解释器分离
2. 优化StringTable的实现: 采用string字符串池
3. 优化ADD,SUB,MUL,DIV的解释实现
4. 优化SelfExplain的标记解析代码结构
5. 实现SUB,MUL,DIV的整型运算
6. 添加ADD_TRANSLATIONS标记

