A->B,B->C(A-->C) : translate pipe
B->C : language stack (can recognize A and B)  A->B || B->C || A->B,B->C
C : interpret C instructions


1. control logic

	s1: A->B
	s2: B->C
	s3: C

	for item in Si:
		if left->right match left
		then do the action (translate or interpret)
			if the action is translate
				the right is the output
				if right === left 
					output the right
				else
					iterator the right, put the output as input
		else output the unmatched input


2. define units and compose them together.
	units:
		u1: A->B
		u2: B->C
		u3: C

	compose:
		A->B,B->C as A-->C like pipe
		A-->C || B-->C like Union operator


3. 嵌入lisp子解释函数支持
语法:
	(LOAD_TRANSLATIONS <语法表达式>)
	(ADD_TRANSLATIONS <语法表达式>)

支持:
	1. 独立LoadWll0相关函数[done]
	2. 子解释添加LOAD_TRANSLATIONS标记的解释[done]
	3. 注意输入状态[done]

SelfExplain自解释和Translate翻译函数的功能分布改造
	改造思路: 
		1. Translate函数继续保持文法结构翻译的简洁性,但是需要考虑对直接引用源语言变量值的支持.[done]
		2. SelfExplain简化对自解释/文法输出的分支判断(之前是通过识别$WLL0来实现的),把他们统一视为对文法中特殊REMARK的处理.[done]

问题一:	是否需要保留原有的自解释语法标记?
	解决方案: 可以保留原有的自解释语法标记,以便直接兼容原有文法. 括号标记文法是可以和原有自解释语法标记兼容的. [done][data/wll1/grammar.wll0](LOAD_TRANSLATIONS IGNORE($WLL0<wll0>))

问题二: 考虑在对自解释输出代码进行求值的时候,怎样弥合Symbols和abc类中定义的ValueType类型的差异?
是通过扩展Symbols的类型来解决问题,还是通过单独的数据栈来解决问题?
同时需要考虑对变量赋值和引用的处理方法?

问题三: 是时候考虑对 直接引用源语言中文法变量值 的支持了.
	解决方案: 修改Translate算法

其他优化点:
1. 优化代码结构: 语法分析器分离,语法转换器分离,语法解释器分离
2. 优化StringTable的实现: 采用string字符串池
3. 优化ADD,SUB,MUL,DIV的解释实现[partly done]
4. 优化SelfExplain的标记解析代码结构[done]
5. 实现SUB,MUL,DIV的整型运算[done]
6. 添加ADD_TRANSLATIONS标记[done]
7. 采用s表达式结构对wll0语言标记进行自解释执行(wll2)
8. 像lisp语言一样在运行的时候修改程序的s表达式: 
	实现方式一: 调用WllIntepreter嵌套解释执行表达式
	实现方式二: 把input_symbols看做代码栈,代码栈可以在解释执行时进行修改: input_symbols实现为deque<Symbols>&类型,当解释执行的代码消耗后,生成的代码可以input_symbols.push_front(生成的程序表达式)压入当前代码栈的栈顶,以便马上执行生成的代码.
	实现方式三: LL(1)文法解析方式解释执行s程序表达式,嵌套解析方式(类似实现方式一),[优点可能是简单,但是不一定高效] [done Wll2Intepreter]

